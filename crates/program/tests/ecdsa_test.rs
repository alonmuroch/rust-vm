#[cfg(test)]
mod tests {
    use program::ecdsa::verify_signature_hash;

    #[test]
    fn test_verify_signature_hash_with_real_data() {
        println!("=== Testing ECDSA verification with real data ===");
        println!("Message: \"Hello, AVM!\"");

        // Test data with valid ECDSA signature

        // Uncompressed public key (65 bytes)
        let pubkey = [
            0x04, // uncompressed prefix
            // x coordinate (32 bytes)
            0x46, 0x46, 0xae, 0x50, 0x47, 0x31, 0x6b, 0x42,
            0x30, 0xd0, 0x08, 0x6c, 0x8a, 0xce, 0xc6, 0x87,
            0xf0, 0x0b, 0x1c, 0xd9, 0xd1, 0xdc, 0x63, 0x4f,
            0x6c, 0xb3, 0x58, 0xac, 0x0a, 0x9a, 0x8f, 0xff,
            // y coordinate (32 bytes)
            0xfe, 0x77, 0xb4, 0xdd, 0x0a, 0x4b, 0xfb, 0x95,
            0x85, 0x1f, 0x3b, 0x73, 0x55, 0xc7, 0x81, 0xdd,
            0x60, 0xf8, 0x41, 0x8f, 0xc8, 0xa6, 0x5d, 0x14,
            0x90, 0x7a, 0xff, 0x47, 0xc9, 0x03, 0xa5, 0x59
        ];
        println!("Public key (uncompressed): {} bytes", pubkey.len());

        // Valid signature (64 bytes) - r (32 bytes) + s (32 bytes)
        let signature = [
            0xfb, 0x00, 0x99, 0xfc, 0x73, 0xf3, 0xff, 0xf0,
            0x63, 0xe3, 0x55, 0xd4, 0x3f, 0x7b, 0xa8, 0xea,
            0xed, 0x26, 0x8d, 0x07, 0x5d, 0xcb, 0x37, 0x87,
            0x2c, 0xf3, 0x60, 0x66, 0x4e, 0x66, 0x17, 0x56,
            0x08, 0xaf, 0xf6, 0xa8, 0x71, 0x85, 0x09, 0x10,
            0xc1, 0x8c, 0xc2, 0x1c, 0x61, 0x36, 0xda, 0xad,
            0x47, 0x0e, 0xc9, 0x24, 0x0b, 0x11, 0x79, 0xe8,
            0xc5, 0x38, 0x79, 0xa9, 0x60, 0x80, 0xbd, 0xa2
        ];
        println!("Signature (r||s): {} bytes", signature.len());

        // Message hash (32 bytes) - SHA256("Hello, AVM!")
        let message_hash = [
            0xd3, 0xb6, 0xe5, 0x0f, 0x20, 0x34, 0x37, 0xd2,
            0x5d, 0x14, 0x02, 0x4d, 0xa4, 0x90, 0x9f, 0x89,
            0x82, 0x4f, 0x1f, 0x33, 0x73, 0xa1, 0x21, 0x37,
            0x05, 0xd1, 0xa1, 0xd4, 0x22, 0x24, 0x85, 0x31
        ];
        println!("Message hash (SHA256): {} bytes", message_hash.len());

        // This should verify successfully
        println!("Verifying signature...");
        let result = verify_signature_hash(&pubkey, &signature, &message_hash);

        match &result {
            Ok(()) => println!("✓ Signature verification SUCCESSFUL"),
            Err(e) => println!("✗ Signature verification FAILED: {}", e),
        }

        assert!(result.is_ok(), "Valid signature should verify successfully");
    }

    #[test]
    fn test_verify_signature_hash_with_second_transaction_data() {
        println!("=== Testing ECDSA verification with second set of data ===");
        println!("Message: \"Test message\"");

        // Second test with different valid ECDSA signature

        // Different uncompressed public key (65 bytes)
        let pubkey = [
            0x04, // uncompressed prefix
            // x coordinate (32 bytes)
            0x88, 0xe2, 0xdd, 0xeb, 0x04, 0x65, 0x7d, 0xbd,
            0x0e, 0xda, 0xdf, 0x9c, 0x1f, 0x98, 0xda, 0x3b,
            0x38, 0x95, 0xfa, 0xa1, 0xf0, 0x05, 0x27, 0x93,
            0x4d, 0xd3, 0x5d, 0x17, 0x54, 0x2f, 0xfe, 0x9b,
            // y coordinate (32 bytes)
            0x1e, 0x76, 0x40, 0xd7, 0x73, 0x7e, 0x24, 0xe3,
            0x6d, 0x20, 0x8e, 0xff, 0xb7, 0x7e, 0x86, 0xaf,
            0xfe, 0x67, 0x0a, 0x9a, 0x49, 0x7a, 0xa7, 0xfb,
            0x52, 0xbf, 0x4e, 0x68, 0x7a, 0x17, 0xff, 0xf4
        ];

        // Different signature (64 bytes) - r (32 bytes) + s (32 bytes)
        let signature = [
            0x3f, 0xa6, 0x8f, 0x2d, 0xfc, 0x12, 0xf0, 0x08,
            0xc5, 0xa2, 0xb9, 0x49, 0x1a, 0x7e, 0x8e, 0xba,
            0xab, 0xb9, 0x42, 0x2b, 0x88, 0x35, 0xfd, 0x03,
            0x97, 0x87, 0x33, 0xfb, 0xcd, 0x0e, 0xe0, 0x00,
            0x51, 0xc9, 0x9b, 0x2b, 0x47, 0xb0, 0x65, 0xd9,
            0x30, 0xc2, 0x8a, 0x20, 0x8c, 0xe1, 0xe3, 0x1b,
            0x0e, 0x1a, 0x84, 0x1e, 0x2a, 0x88, 0xfa, 0x43,
            0x44, 0xd2, 0x6a, 0xf3, 0x68, 0x36, 0x0e, 0x7f
        ];

        // Different message hash (32 bytes) - SHA256("Test message")
        let message_hash = [
            0xc0, 0x71, 0x9e, 0x9a, 0x8d, 0x5d, 0x83, 0x8d,
            0x86, 0x1d, 0xc6, 0xf6, 0x75, 0xc8, 0x99, 0xd2,
            0xb3, 0x09, 0xa3, 0xa6, 0x5b, 0xb9, 0xfe, 0x6b,
            0x11, 0xe5, 0xaf, 0xcb, 0xf9, 0xa2, 0xc0, 0xb1
        ];

        // This should verify successfully
        println!("Verifying signature...");
        let result = verify_signature_hash(&pubkey, &signature, &message_hash);

        match &result {
            Ok(()) => println!("✓ Signature verification SUCCESSFUL"),
            Err(e) => println!("✗ Signature verification FAILED: {}", e),
        }

        assert!(result.is_ok(), "Valid signature should verify successfully");
    }

    #[test]
    fn test_verify_signature_hash_with_invalid_signature() {
        println!("=== Testing ECDSA verification with invalid signature ===");
        // Use valid pubkey and message hash but tamper with signature

        let pubkey = [
            0x04, // uncompressed prefix
            // x coordinate (32 bytes)
            0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac,
            0x55, 0xa0, 0x62, 0x95, 0xce, 0x87, 0x0b, 0x07,
            0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce, 0x28, 0xd9,
            0x59, 0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98,
            // y coordinate (32 bytes)
            0x48, 0x3a, 0xda, 0x77, 0x26, 0xa3, 0xc4, 0x65,
            0x5d, 0xa4, 0xfb, 0xfc, 0x0e, 0x11, 0x08, 0xa8,
            0xfd, 0x17, 0xb4, 0x48, 0xa6, 0x85, 0x54, 0x19,
            0x9c, 0x47, 0xd0, 0x8f, 0xfb, 0x10, 0xd4, 0xb8
        ];

        // Invalid signature - modified first byte
        let signature = [
            // r component (modified)
            0x00, 0x04, 0x7f, 0x94, 0x41, 0xed, 0x7d, 0x6d,
            0x30, 0x45, 0x40, 0x6e, 0x95, 0xc0, 0x7c, 0xd8,
            0x5c, 0x77, 0x8e, 0x4b, 0x8c, 0xef, 0x3c, 0xa7,
            0xab, 0xac, 0x09, 0xb9, 0x5c, 0x70, 0x9e, 0xe5,
            // s component
            0x1a, 0xe1, 0x68, 0xa8, 0xc0, 0x59, 0x1b, 0xd5,
            0xc5, 0xea, 0x69, 0x11, 0xc5, 0x15, 0x90, 0x11,
            0xe3, 0x89, 0xf6, 0x8c, 0xd5, 0x63, 0x5f, 0xac,
            0xac, 0xb1, 0x35, 0xc0, 0x41, 0x0e, 0x38, 0xac
        ];

        let message_hash = [
            0x2c, 0xf2, 0x4d, 0xba, 0x5f, 0xb0, 0xa3, 0x0e,
            0x26, 0xe8, 0x3b, 0x2a, 0xc5, 0xb9, 0xe2, 0x9e,
            0x1b, 0x16, 0x1e, 0x5c, 0x1f, 0xa7, 0x42, 0x5e,
            0x73, 0x04, 0x33, 0x62, 0x93, 0x8b, 0x98, 0x24
        ];

        // This should fail verification
        println!("Verifying tampered signature (first byte changed from 0xfb to 0x00)...");
        let result = verify_signature_hash(&pubkey, &signature, &message_hash);

        match &result {
            Ok(()) => println!("✗ Unexpected: Invalid signature verification PASSED"),
            Err(e) => println!("✓ Expected failure: {}", e),
        }

        assert!(result.is_err(), "Invalid signature should fail verification");
    }

    #[test]
    fn test_verify_signature_hash_with_wrong_message_hash() {
        println!("=== Testing ECDSA verification with wrong message hash ===");
        // Use valid pubkey and signature but different message hash

        let pubkey = [
            0x04, // uncompressed prefix
            // x coordinate (32 bytes)
            0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac,
            0x55, 0xa0, 0x62, 0x95, 0xce, 0x87, 0x0b, 0x07,
            0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce, 0x28, 0xd9,
            0x59, 0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98,
            // y coordinate (32 bytes)
            0x48, 0x3a, 0xda, 0x77, 0x26, 0xa3, 0xc4, 0x65,
            0x5d, 0xa4, 0xfb, 0xfc, 0x0e, 0x11, 0x08, 0xa8,
            0xfd, 0x17, 0xb4, 0x48, 0xa6, 0x85, 0x54, 0x19,
            0x9c, 0x47, 0xd0, 0x8f, 0xfb, 0x10, 0xd4, 0xb8
        ];

        let signature = [
            // r component
            0xc6, 0x04, 0x7f, 0x94, 0x41, 0xed, 0x7d, 0x6d,
            0x30, 0x45, 0x40, 0x6e, 0x95, 0xc0, 0x7c, 0xd8,
            0x5c, 0x77, 0x8e, 0x4b, 0x8c, 0xef, 0x3c, 0xa7,
            0xab, 0xac, 0x09, 0xb9, 0x5c, 0x70, 0x9e, 0xe5,
            // s component
            0x1a, 0xe1, 0x68, 0xa8, 0xc0, 0x59, 0x1b, 0xd5,
            0xc5, 0xea, 0x69, 0x11, 0xc5, 0x15, 0x90, 0x11,
            0xe3, 0x89, 0xf6, 0x8c, 0xd5, 0x63, 0x5f, 0xac,
            0xac, 0xb1, 0x35, 0xc0, 0x41, 0x0e, 0x38, 0xac
        ];

        // Wrong message hash - all zeros
        let message_hash = [0u8; 32];

        // This should fail verification
        println!("Verifying with wrong message hash (all zeros)...");
        let result = verify_signature_hash(&pubkey, &signature, &message_hash);

        match &result {
            Ok(()) => println!("✗ Unexpected: Wrong message hash verification PASSED"),
            Err(e) => println!("✓ Expected failure: {}", e),
        }

        assert!(result.is_err(), "Wrong message hash should fail verification");
    }

    #[test]
    fn test_verify_signature_hash_with_invalid_pubkey() {
        println!("=== Testing ECDSA verification with invalid public key ===");
        // Invalid public key format
        let invalid_pubkey = [0xFF; 65]; // Invalid pubkey

        let signature = [
            // r component
            0xc6, 0x04, 0x7f, 0x94, 0x41, 0xed, 0x7d, 0x6d,
            0x30, 0x45, 0x40, 0x6e, 0x95, 0xc0, 0x7c, 0xd8,
            0x5c, 0x77, 0x8e, 0x4b, 0x8c, 0xef, 0x3c, 0xa7,
            0xab, 0xac, 0x09, 0xb9, 0x5c, 0x70, 0x9e, 0xe5,
            // s component
            0x1a, 0xe1, 0x68, 0xa8, 0xc0, 0x59, 0x1b, 0xd5,
            0xc5, 0xea, 0x69, 0x11, 0xc5, 0x15, 0x90, 0x11,
            0xe3, 0x89, 0xf6, 0x8c, 0xd5, 0x63, 0x5f, 0xac,
            0xac, 0xb1, 0x35, 0xc0, 0x41, 0x0e, 0x38, 0xac
        ];

        let message_hash = [
            0x2c, 0xf2, 0x4d, 0xba, 0x5f, 0xb0, 0xa3, 0x0e,
            0x26, 0xe8, 0x3b, 0x2a, 0xc5, 0xb9, 0xe2, 0x9e,
            0x1b, 0x16, 0x1e, 0x5c, 0x1f, 0xa7, 0x42, 0x5e,
            0x73, 0x04, 0x33, 0x62, 0x93, 0x8b, 0x98, 0x24
        ];

        println!("Verifying with invalid public key (all 0xFF bytes)...");
        let result = verify_signature_hash(&invalid_pubkey, &signature, &message_hash);

        match &result {
            Ok(()) => println!("✗ Unexpected: Invalid pubkey verification PASSED"),
            Err(e) => println!("✓ Expected failure: {}", e),
        }

        assert!(result.is_err(), "Invalid public key should return error");
        assert_eq!(result.unwrap_err(), "Invalid public key");
    }

    #[test]
    fn test_verify_signature_hash_with_wrong_hash_size() {
        println!("=== Testing ECDSA verification with wrong hash size ===");
        let pubkey = [
            0x04, // uncompressed prefix
            // x coordinate (32 bytes)
            0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac,
            0x55, 0xa0, 0x62, 0x95, 0xce, 0x87, 0x0b, 0x07,
            0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce, 0x28, 0xd9,
            0x59, 0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98,
            // y coordinate (32 bytes)
            0x48, 0x3a, 0xda, 0x77, 0x26, 0xa3, 0xc4, 0x65,
            0x5d, 0xa4, 0xfb, 0xfc, 0x0e, 0x11, 0x08, 0xa8,
            0xfd, 0x17, 0xb4, 0x48, 0xa6, 0x85, 0x54, 0x19,
            0x9c, 0x47, 0xd0, 0x8f, 0xfb, 0x10, 0xd4, 0xb8
        ];

        let signature = [0u8; 64]; // dummy signature

        // Wrong size message hash (not 32 bytes)
        let wrong_size_hash = [0u8; 16];

        println!("Verifying with wrong hash size (16 bytes instead of 32)...");
        let result = verify_signature_hash(&pubkey, &signature, &wrong_size_hash);

        match &result {
            Ok(()) => println!("✗ Unexpected: Wrong hash size verification PASSED"),
            Err(e) => println!("✓ Expected failure: {}", e),
        }

        assert!(result.is_err(), "Wrong hash size should return error");
        assert_eq!(result.unwrap_err(), "Message hash must be 32 bytes");
    }
}